//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : DoorMachine.sm
//

#include "door.h"
#include "DoorMachine_sm.h"

using namespace statemap;

// Static class declarations.
MainMap_WaitingForFaceDetection MainMap::WaitingForFaceDetection("MainMap::WaitingForFaceDetection", 0);
MainMap_WaitingForApproval MainMap::WaitingForApproval("MainMap::WaitingForApproval", 1);
MainMap_Alarm MainMap::Alarm("MainMap::Alarm", 2);
MainMap_Unlocked MainMap::Unlocked("MainMap::Unlocked", 3);

void DoorState::Approval(DoorMachineContext& context, const bool isApproved)
{
    Default(context);
}

void DoorState::ApprovalTimeOut(DoorMachineContext& context)
{
    Default(context);
}

void DoorState::FaceDetected(DoorMachineContext& context, const QByteArray& image)
{
    Default(context);
}

void DoorState::Reset(DoorMachineContext& context)
{
    Default(context);
}

void DoorState::UnlockedTimerTimeOut(DoorMachineContext& context)
{
    Default(context);
}

void DoorState::Default(DoorMachineContext& context)
{
    throw (
        TransitionUndefinedException(
            context.getState().getName(),
            context.getTransition()));

}

void MainMap_WaitingForFaceDetection::Entry(DoorMachineContext& context)

{
    Door& ctxt = context.getOwner();

    ctxt.initialAction();
}

void MainMap_WaitingForFaceDetection::Default(DoorMachineContext& context)
{


}

void MainMap_WaitingForFaceDetection::FaceDetected(DoorMachineContext& context, const QByteArray& image)
{
    Door& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.onFaceDetected(image);
        context.setState(MainMap::WaitingForApproval);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForApproval);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForApproval::Entry(DoorMachineContext& context)

{
    Door& ctxt = context.getOwner();

    ctxt.startApprovalTimer();
}

void MainMap_WaitingForApproval::Exit(DoorMachineContext& context)

{
    Door& ctxt = context.getOwner();

    ctxt.stopApprovalTimer();
}

void MainMap_WaitingForApproval::Approval(DoorMachineContext& context, const bool isApproved)
{
    Door& ctxt = context.getOwner();

    if (isApproved==false)
    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.onNotApproved();
            context.setState(MainMap::Alarm);
        }
        catch (...)
        {
            context.setState(MainMap::Alarm);
            throw;
        }
        context.getState().Entry(context);
    }
    else if (isApproved==true)

    {
        context.getState().Exit(context);
        context.clearState();
        try
        {
            ctxt.onApproved();
            context.setState(MainMap::Unlocked);
        }
        catch (...)
        {
            context.setState(MainMap::Unlocked);
            throw;
        }
        context.getState().Entry(context);
    }    else
    {
         MainMap_Default::Approval(context, isApproved);
    }

}

void MainMap_WaitingForApproval::ApprovalTimeOut(DoorMachineContext& context)
{
    Door& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.onApprovalTimeOut();
        context.setState(MainMap::WaitingForFaceDetection);
    }
    catch (...)
    {
        context.setState(MainMap::WaitingForFaceDetection);
        throw;
    }
    context.getState().Entry(context);

}

void MainMap_WaitingForApproval::Default(DoorMachineContext& context)
{


}

void MainMap_Alarm::Default(DoorMachineContext& context)
{


}

void MainMap_Alarm::Reset(DoorMachineContext& context)
{

    context.getState().Exit(context);
    context.setState(MainMap::WaitingForFaceDetection);
    context.getState().Entry(context);

}

void MainMap_Unlocked::Entry(DoorMachineContext& context)

{
    Door& ctxt = context.getOwner();

    ctxt.startUnlockedTimer();
}

void MainMap_Unlocked::Exit(DoorMachineContext& context)

{
    Door& ctxt = context.getOwner();

    ctxt.stopUnlockedTimer();
}

void MainMap_Unlocked::Default(DoorMachineContext& context)
{


}

void MainMap_Unlocked::UnlockedTimerTimeOut(DoorMachineContext& context)
{

    context.getState().Exit(context);
    context.setState(MainMap::WaitingForFaceDetection);
    context.getState().Entry(context);

}

//
// Local variables:
//  buffer-read-only: t
// End:
//
